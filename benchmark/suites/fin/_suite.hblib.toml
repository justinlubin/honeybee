################################################################################
### GENERIC FUNCTIONS ###
################################################################################

[Prop.In]
params.x = "Int"

[Type.Choice]
params.x = "Int"

[Function.choose]
params = {}
ret = "Choice"
condition = ["In { x = ret.x }"]

### independent_choices

# Types

[Type.Step1]
params = {}

[Type.Step2]
params = {}

[Type.Step3]
params = {}

[Type.Step4]
params = {}

[Type.Step5]
params = {}

[Type.Step6]
params = {}

[Type.Step7]
params = {}

[Type.Step8]
params = {}

[Type.Step9]
params = {}

[Type.Step10]
params = {}

# Step 1

[Function.a1]
params.in = "Choice"
ret = "Step1"
condition = []

[Function.b1]
params.in = "Choice"
ret = "Step1"
condition = []

[Function.c1]
params.in = "Choice"
ret = "Step1"
condition = []

[Function.d1]
params.in = "Choice"
ret = "Step1"
condition = []

[Function.e1]
params.in = "Choice"
ret = "Step1"
condition = []

# Step 2

[Function.a2]
params.in = "Step1"
ret = "Step2"
condition = []

[Function.b2]
params.in = "Step1"
ret = "Step2"
condition = []

[Function.c2]
params.in = "Step1"
ret = "Step2"
condition = []

[Function.d2]
params.in = "Step1"
ret = "Step2"
condition = []

[Function.e2]
params.in = "Step1"
ret = "Step2"
condition = []

# Step 3

[Function.a3]
params.in = "Step2"
ret = "Step3"
condition = []

[Function.b3]
params.in = "Step2"
ret = "Step3"
condition = []

[Function.c3]
params.in = "Step2"
ret = "Step3"
condition = []

[Function.d3]
params.in = "Step2"
ret = "Step3"
condition = []

[Function.e3]
params.in = "Step2"
ret = "Step3"
condition = []

# Step 4

[Function.a4]
params.in = "Step3"
ret = "Step4"
condition = []

[Function.b4]
params.in = "Step3"
ret = "Step4"
condition = []

[Function.c4]
params.in = "Step3"
ret = "Step4"
condition = []

[Function.d4]
params.in = "Step3"
ret = "Step4"
condition = []

[Function.e4]
params.in = "Step3"
ret = "Step4"
condition = []

# Step 5

[Function.a5]
params.in = "Step4"
ret = "Step5"
condition = []

[Function.b5]
params.in = "Step4"
ret = "Step5"
condition = []

[Function.c5]
params.in = "Step4"
ret = "Step5"
condition = []

[Function.d5]
params.in = "Step4"
ret = "Step5"
condition = []

[Function.e5]
params.in = "Step4"
ret = "Step5"
condition = []

# Step 6

[Function.a6]
params.in = "Step5"
ret = "Step6"
condition = []

[Function.b6]
params.in = "Step5"
ret = "Step6"
condition = []

[Function.c6]
params.in = "Step5"
ret = "Step6"
condition = []

[Function.d6]
params.in = "Step5"
ret = "Step6"
condition = []

[Function.e6]
params.in = "Step5"
ret = "Step6"
condition = []

# Step 7

[Function.a7]
params.in = "Step6"
ret = "Step7"
condition = []

[Function.b7]
params.in = "Step6"
ret = "Step7"
condition = []

[Function.c7]
params.in = "Step6"
ret = "Step7"
condition = []

[Function.d7]
params.in = "Step6"
ret = "Step7"
condition = []

[Function.e7]
params.in = "Step6"
ret = "Step7"
condition = []

# Step 8

[Function.a8]
params.in = "Step7"
ret = "Step8"
condition = []

[Function.b8]
params.in = "Step7"
ret = "Step8"
condition = []

[Function.c8]
params.in = "Step7"
ret = "Step8"
condition = []

[Function.d8]
params.in = "Step7"
ret = "Step8"
condition = []

[Function.e8]
params.in = "Step7"
ret = "Step8"
condition = []

# Step 9

[Function.a9]
params.in = "Step8"
ret = "Step9"
condition = []

[Function.b9]
params.in = "Step8"
ret = "Step9"
condition = []

[Function.c9]
params.in = "Step8"
ret = "Step9"
condition = []

[Function.d9]
params.in = "Step8"
ret = "Step9"
condition = []

[Function.e9]
params.in = "Step8"
ret = "Step9"
condition = []

# Step 10

[Function.a10]
params.in = "Step9"
ret = "Step10"
condition = []

[Function.b10]
params.in = "Step9"
ret = "Step10"
condition = []

[Function.c10]
params.in = "Step9"
ret = "Step10"
condition = []

[Function.d10]
params.in = "Step9"
ret = "Step10"
condition = []

[Function.e10]
params.in = "Step9"
ret = "Step10"
condition = []

### rabbit_hole

[Type.RabbitHole]
params = {}

[Type.RHGoal]
params = {}

[Function.rh_continue]
params.in = "RabbitHole"
ret = "RabbitHole"
condition = []

[Function.rh]
params.in = "RabbitHole"
ret = "RHGoal"
condition = []

[Function.non_rh]
params.in = "Choice"
ret = "RHGoal"
condition = []

###  limited_cycle

[Type.LimitedCycle]
params.count = "Int"

[Type.LimitedCycleAnswer]
params = {}

[Function.start_lc]
params.in = "Choice"
ret = "LimitedCycle"
condition = ["ret.count = in.x"]

[Function.continue_lc]
params.in = "LimitedCycle"
ret = "LimitedCycle"
condition = [
    "ret.count < in.count",
    "0 < ret.count",
]

[Function.end_lc]
params.in = "LimitedCycle"
ret = "LimitedCycleAnswer"
condition = []

### branches

[Type.BranchTop]
params = {}

[Type.BranchMid]
params = {}

[Function.btop]
params.b1 = "BranchMid"
params.b2 = "BranchMid"
params.b3 = "BranchMid"
params.b4 = "BranchMid"
ret = "BranchTop"
condition = []

[Function.bmid1]
params.in1 = "Choice"
params.in2 = "Choice"
ret = "BranchMid"
condition = []

[Function.bmid2]
params.in1 = "Choice"
params.in2 = "Choice"
ret = "BranchMid"
condition = []

[Function.bmid3]
params.in1 = "Choice"
params.in2 = "Choice"
ret = "BranchMid"
condition = []

[Function.bmid_impossible1]
params.in1 = "Choice"
params.in2 = "Choice"
ret = "BranchMid"
condition = [
    "in1.x = in2.x",
    "in1.x < in2.x",
]

[Function.bmid_impossible2]
params.in1 = "Choice"
params.in2 = "Choice"
ret = "BranchMid"
condition = [
    "in2.x < in1.x",
    "in1.x < in2.x",
]

### breadth_sorted

[Type.BreadthSorted]
params = {}

[Function.breadth_sorted]
params.in1 = "Choice"
params.in2 = "Choice"
params.in3 = "Choice"
params.in4 = "Choice"
params.in5 = "Choice"
ret = "BreadthSorted"
condition = [
    "in1.x < in2.x",
    "in2.x < in3.x",
    "in3.x < in4.x",
    "in4.x < in5.x",
]

# ;;; depth_sorted
#
# (output fact DepthSorted)
#
# (output fact DS1 (.x Int))
# (output fact DS2 (.x Int))
# (output fact DS3 (.x Int))
# (output fact DS4 (.x Int))
#
# (computation as0 DepthSorted
#   ((in DS1)) ())
#
# (computation as1 DS1
#   ((in DS2))
#   ((< (.x ret) (.x in))))
#
# (computation as2 DS2
#   ((in DS3))
#   ((< (.x ret) (.x in))))
#
# (computation as3 DS3
#   ((in DS4))
#   ((< (.x ret) (.x in))))
#
# (computation as4 DS4
#   ((in In))
#   ((< (.x ret) (.x in))))
#
# ;;; same
#
# (output fact Same)
# (output fact SameOption (.x Int))
#
# (computation same Same
#   ((s1 SameOption) (s2 SameOption) (s3 SameOption) (s4 SameOption)
#    (s5 SameOption) (s6 SameOption) (s7 SameOption) (s8 SameOption)
#    (s9 SameOption) (s10 SameOption))
#   ((= (.x s1) (.x s2))
#    (= (.x s2) (.x s3))
#    (= (.x s3) (.x s4))
#    (= (.x s4) (.x s5))
#    (= (.x s5) (.x s6))
#    (= (.x s6) (.x s7))
#    (= (.x s7) (.x s8))
#    (= (.x s8) (.x s9))
#    (= (.x s9) (.x s10))))
#
# (computation same_option SameOption
#   ((in In))
#   ((= (.x ret) (.x in))))
#
# ;;; descending_tree
#
# (output fact DTree (.x Int))
#
# (computation dtree DTree
#   ((dt1 DTree) (dt2 DTree))
#   ((< (.x dt1) (.x ret))
#    (< (.x dt2) (.x ret))
#    (< (.x dt2) (.x dt1))))
#
# (computation dtree_leaf DTree
#   () ())
#
# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
# ;;; BIOINFORMATICS ANALYSES ;;;
# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#
# ; Raw inputs
#
# (input fact Seq
#   (.sample Str) (.at Int) (.data Str))
#
# (input fact ReferenceGenome
#   (.data Str))
#
# ; Datatypes
#
# (output fact Reference
#   (.data Str))
#
# (output fact Alignment
#   (.sample Str) (.at Int))
#
# (output fact ReadCounts
#   (.sample Str) (.at Int))
#
# (output fact ReadCountMatrix
#   (.sample1 Str) (.sample2 Str) (.at Int) (.bc Int))
#
# (output fact DifferentialGeneExpression
#   (.sample1 Str) (.sample2 Str) (.at Int))
#
# ; Load reference genome
#
# (computation load_local_reference_genome Reference
#   ((rg ReferenceGenome))
#   ((= (.data ret) (.data rg))))
#
# (computation load_hg38 Reference () ())
#
# ; Quantifiers
#
# (computation kallisto ReadCounts
#   ((seq Seq) (ref Reference))
#   ((= (.sample ret) (.sample seq))
#    (= (.at ret) (.at seq))))
#
# (computation salmon ReadCounts
#   ((seq Seq) (ref Reference))
#   ((= (.sample ret) (.sample seq))
#    (= (.at ret) (.at seq))))
#
# ; Aligners
#
# (computation bowtie2 Alignment
#   ((seq Seq) (ref Reference))
#   ((= (.sample ret) (.sample seq))
#    (= (.at ret) (.at seq))))
#
# (computation star Alignment
#   ((seq Seq) (ref Reference))
#   ((= (.sample ret) (.sample seq))
#    (= (.at ret) (.at seq))))
#
# ; Read summarization
#
# (computation featureCounts ReadCounts
#   ((a Alignment))
#   ((= (.sample ret) (.sample a))
#    (= (.at ret) (.at a))))
#
# ; Combine reads
#
# (computation combine_reads ReadCountMatrix
#   ((r1 ReadCounts) (r2 ReadCounts))
#   ((= (.sample1 ret) (.sample r1))
#    (= (.sample2 ret) (.sample r2))
#    (= (.at ret) (.at r1))
#    (= (.at r1) (.at r2))
#    (= (.bc ret) 0)))
#
# ; Batch correction
#
# (computation combat_seq ReadCountMatrix
#   ((rcm ReadCountMatrix))
#   ((= (.sample1 ret) (.sample1 rcm))
#    (= (.sample2 ret) (.sample2 rcm))
#    (= (.at ret) (.at rcm))
#    (= (.bc rcm) 0)
#    (= (.bc ret) 1)))
#
# ; Differential gene expression
#
# (computation deseq2 DifferentialGeneExpression
#   ((rcm ReadCountMatrix))
#   ((= (.sample1 ret) (.sample1 rcm))
#    (= (.sample2 ret) (.sample2 rcm))
#    (= (.at ret) (.at rcm))))
#
# ; Pooled CRISPR screen
#
# (input fact Transfection
#   (.sample Str) (.at Int) (.library Str))
#
# (output fact Enrichment
#   (.sample Str) (.start Int) (.end Int))
#
# (computation reference_from_transfection Reference
#   ((t Transfection))
#   ((= (.data ret) (.library t))))
#
# (computation mageck Enrichment
#   ((t Transfection) (s1 Seq) (s2 Seq))
#   ((= (.sample ret) (.sample t))
#    (= (.start ret) (.at s1))
#    (= (.end ret) (.at s2))
#    (= (.sample t) (.sample s1))
#    (= (.sample t) (.sample s2))
#    (< (.at t) (.at s1))
#    (< (.at s1) (.at s2))))
#
# (computation l2fc Enrichment
#   ((r1 ReadCounts) (r2 ReadCounts))
#   ((= (.start ret) (.at r1))
#    (= (.end ret) (.at r2))
#    (= (.sample ret) (.sample r1))
#    (= (.sample ret) (.sample r2))
#    (< (.at r1) (.at r2))))
