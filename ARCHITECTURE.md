# Architecture

This file documents the high-level architecture of this repository. Further documentation can be found in the code modules themselves.

This repository is split into three main sections:
1. The main implementation of Honeybee (in `backend`)
2. The evaluation materials (in `benchmark`)
3 The top-level helper scripts

The following sections provide additional details about these sections.

## Main implementation

The `backend/` directory contains all the code (written in Rust) for implementing the synthesizers that are used as part of Honeybee.

The entry point is `main.rs`; this file defines all the command line arguments for Honeybee.


## Evaluation materials

The `suites/` subdirectory contains all of the benchmark entries, split into three suites:

- `fin` (entries with finitely many solutions),
- `inf` (entries with infinitely many solutions), and
- `scal` (entries with varying depth and breadth of search space, programmatically generated by the `generate.py` script in this directory).

Each entry (`.hb.toml` file) has 10 associated solutions that the synthesizers must find as part of the evaluation (except for some that have less than 10 total solutions). These solutions are found in the folder of the same name of the example and were programmatically-generated by randomly choosing steps via the `particular_driver.py` script (except for those that have a `MANUAL.txt` file associated with them; these could not be generated programatically, as described in the paper).

The `data/` subdirectory is a convenient location to store the raw results of the `benchmark` subcommand of the main implementation. 

The `analysis/` subdirectory contains a small Python uv project to analyze the raw data produced by the `benchmark` subcommand. The main script is `analyze.py` (it contains its own usage documentation) and helper functions are stored in `lib.py`.

The `analysis/output/` subdirectory is a convenient location to store the results of the above `analyze.py` script.

## Top-level helper scripts

* `BUILD_DOCKER.sh` creates a Docker image (for use in the PLDI '25 Artifact Evaluation)
* `RUN_DOCKER.sh` runs this image, setting up the necessary files in the process.
* `RUN_QUICK_EVAL.sh` and `RUN_FULL_EVAL.sh` provide methods to run the paper evaluation (see `README.md` for more details).
* `RUN_OVERVIEW_EXAMPLE.sh` runs the example from the overview in the paper and serves as an example for how to call the synthesizer interactively.
* `KICK_TIRES.sh` checks to make sure all the external dependencies (Rust and uv) are installed correctly.