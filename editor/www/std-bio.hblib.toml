[[Preamble]]
content = '''from dataclasses import dataclass
import datetime
import os
import polars as pl'''

[[Preamble]]
content='''class Dir:
    stage = 1

    def make(name):
        time = datetime.datetime.today().strftime("%Y-%m-%d-%H-%M-%S")
        dir = f"output-{time}/{Dir.stage * 10:03d}-{name}"
        os.makedirs(dir, exist_ok=True)
        Dir.stage += 1
        return dir'''

[[Preamble]]
content='''def carry_over(src_object, dst_object, *, file=None):
    def carry_one(file):
        src = f"{src_object.path}/{file}"
        dst = f"{dst_object.path}/{file}"
        if os.path.islink(src):
            src = os.readlink(src)
        os.symlink(src=src, dst=dst)

    if file is None:
        for file in os.listdir(src_object.path):
            carry_one(file)
    else:
        carry_one(file)'''

[Type.LocalRnaSeq]
params.sample_sheet = "Str"
params.path = "Str"
info.title = "RNA-seq (stored on your own hard drive)"
info.param_titles.sample_sheet = "Path to sample sheet CSV with SRA metadata"
info.param_descriptions.sample_sheet = """
Here is an example CSV file (the headers must match exactly):

| sample_name | condition | replicate |
|-------------|-----------|-----------|
| JPL001_t1   | treated   | 1         |
| JPL002_t2   | treated   | 2         |
| JPL003_u1   | untreated | 1         |
| JPL004_u2   | untreated | 2         |

The `sample_name` column can contain whatever you'd like, as long as each
row is unique."""
info.param_examples.sample_sheet = """/Users/jlubin/Desktop/MyExperiment/metadata/sample_sheet.csv"""
info.param_titles.path = "Path to the directory containing the RNA-seq data"
info.param_descriptions.path = """
This directory should contain files ending with `.fastq` or `.fastq.gz`."""
info.param_examples.path = """/Users/jlubin/Desktop/MyExperiment/raw-fastq-reads/"""
info.code = '''@dataclass
class LocalRnaSeq:
    "RNA-seq (stored on your own hard drive)"

    sample_sheet: str
    """Path to sample sheet CSV with SRA metadata

    @example:/Users/jlubin/Desktop/MyExperiment/metadata/sample_sheet.csv

    Here is an example CSV file (the headers must match exactly):

    | sample_name | condition | replicate |
    |-------------|-----------|-----------|
    | JPL001_t1   | treated   | 1         |
    | JPL002_t2   | treated   | 2         |
    | JPL003_u1   | untreated | 1         |
    | JPL004_u2   | untreated | 2         |

    The `sample_name` column can contain whatever you'd like, as long as each
    row is unique."""

    path: str
    """Path to the directory containing the RNA-seq data

    @example:/Users/jlubin/Desktop/MyExperiment/raw-fastq-reads/

    This directory should contain files ending with `.fastq` or `.fastq.gz`."""'''

[Prop.P_LocalRnaSeq]
params.sample_sheet = "Str"
params.path = "Str"
info.title = "RNA-seq (stored on your own hard drive)"
info.param_titles.sample_sheet = "Path to sample sheet CSV with SRA metadata"
info.param_descriptions.sample_sheet = """
Here is an example CSV file (the headers must match exactly):

| sample_name | condition | replicate |
|-------------|-----------|-----------|
| JPL001_t1   | treated   | 1         |
| JPL002_t2   | treated   | 2         |
| JPL003_u1   | untreated | 1         |
| JPL004_u2   | untreated | 2         |

The `sample_name` column can contain whatever you'd like, as long as each
row is unique."""
info.param_examples.sample_sheet = """/Users/jlubin/Desktop/MyExperiment/metadata/sample_sheet.csv"""
info.param_titles.path = "Path to the directory containing the RNA-seq data"
info.param_descriptions.path = """
This directory should contain files ending with `.fastq` or `.fastq.gz`."""
info.param_examples.path = """/Users/jlubin/Desktop/MyExperiment/raw-fastq-reads/"""

[Function.F_LocalRnaSeq]
params = {}
ret = "LocalRnaSeq"
condition = [
    "P_LocalRnaSeq { sample_sheet = ret.sample_sheet, path = ret.path }"
]
info.title = "RNA-seq (stored on your own hard drive)"

[Type.SraRnaSeq]
params.sample_sheet = "Str"
info.title = "RNA-seq (stored on the Sequence Read Archive)"
info.param_titles.sample_sheet = "Path to sample sheet CSV with SRA metadata"
info.param_descriptions.sample_sheet = """
Here is an example CSV file (the headers must match exactly):

| sample_name | condition | replicate |
|-------------|-----------|-----------|
| SRR34323945 | treated   | 1         |
| SRR34323944 | treated   | 2         |
| SRR34323943 | untreated | 1         |
| SRR34323942 | untreated | 2         |

**Important:** The `sample_name` column must contain valid SRA "run
accessions" (SRRs). They are of the form SRR*xxxxxxxx*, where each *x* is
digit."""
info.param_examples.sample_sheet = """/Users/jlubin/Desktop/MyExperiment/metadata/sample_sheet.csv"""
info.code = '''@dataclass
class SraRnaSeq:
    "RNA-seq (stored on the Sequence Read Archive)"

    sample_sheet: str
    """Path to sample sheet CSV with SRA metadata

    @example:/Users/jlubin/Desktop/MyExperiment/metadata/sample_sheet.csv

    Here is an example CSV file (the headers must match exactly):

    | sample_name | condition | replicate |
    |-------------|-----------|-----------|
    | SRR34323945 | treated   | 1         |
    | SRR34323944 | treated   | 2         |
    | SRR34323943 | untreated | 1         |
    | SRR34323942 | untreated | 2         |

    **Important:** The `sample_name` column must contain valid SRA "run
    accessions" (SRRs). They are of the form SRR*xxxxxxxx*, where each *x* is
    digit."""'''

[Prop.P_SraRnaSeq]
params.sample_sheet = "Str"
info.title = "RNA-seq (stored on the Sequence Read Archive)"
info.param_titles.sample_sheet = "Path to sample sheet CSV with SRA metadata"
info.param_descriptions.sample_sheet = """
Here is an example CSV file (the headers must match exactly):

| sample_name | condition | replicate |
|-------------|-----------|-----------|
| SRR34323945 | treated   | 1         |
| SRR34323944 | treated   | 2         |
| SRR34323943 | untreated | 1         |
| SRR34323942 | untreated | 2         |

**Important:** The `sample_name` column must contain valid SRA "run
accessions" (SRRs). They are of the form SRR*xxxxxxxx*, where each *x* is
digit."""
info.param_examples.sample_sheet = """/Users/jlubin/Desktop/MyExperiment/metadata/sample_sheet.csv"""

[Function.F_SraRnaSeq]
params = {}
ret = "SraRnaSeq"
condition = [
    "P_SraRnaSeq { sample_sheet = ret.sample_sheet }"
]
info.title = "RNA-seq (stored on the Sequence Read Archive)"

[Type.RnaSeqReads]
params.qc = "Bool"
params.trimmed = "Bool"
info.title = "@intermediate:RNA-seq reads"
info.description = """The goal of this step is to get RNA-seq reads.

These reads can either be raw data (that is, the direct output of a machine
like an
[Illumina sequencer](https://www.illumina.com/systems/sequencing-platforms.html), or
can be the result of pre-processing that raw data.

Many pre-processing techniques (like
[adapter trimming](https://knowledge.illumina.com/software/general/software-general-reference_material-list/000002905))
require that the RNA-seq reads undergo _quality control_ (QC) checks using
a tool like
[FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
before and after running the tool."""
info.code = '''@dataclass
class RnaSeqReads:
    """@intermediate:RNA-seq reads

    The goal of this step is to get RNA-seq reads.

    These reads can either be raw data (that is, the direct output of a machine
    like an
    [Illumina sequencer](https://www.illumina.com/systems/sequencing-platforms.html), or
    can be the result of pre-processing that raw data.

    Many pre-processing techniques (like
    [adapter trimming](https://knowledge.illumina.com/software/general/software-general-reference_material-list/000002905))
    require that the RNA-seq reads undergo _quality control_ (QC) checks using
    a tool like
    [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
    before and after running the tool."""

    path: str

    qc: bool
    trimmed: bool'''

[Function.from_sra_rna_seq]
params.sra = "SraRnaSeq"
ret = "RnaSeqReads"
condition = [
    "ret.qc = false",
    "ret.trimmed = false",
]
info.title = "Download from ENA"
info.description = """# Download RNA-seq data from the [European Nucleotide Archive](https://www.ebi.ac.uk/ena/browser/home) by SRR accession identifiers

The downloaded files will be in the .fastq.gz file format, with the
filenames for the forward reads ending in _1.fastq.gz and the filenames for
the reverse reads ending in _2.fastq.gz."""
info.hyperparameters = [
]
info.code = '''sample_sheet = pl.read_csv(__hb_sra.sample_sheet)

for srr in sample_sheet["sample_name"]:
    base_url = "ftp://ftp.sra.ebi.ac.uk/vol1/fastq/"
    base_url += srr[:6] + "/"
    base_url += srr[9:].zfill(3) + "/"
    base_url += srr + "/"

    # Assumes forward (_1) and reverse (_2) reads exist

    __hb_bash(f"""
         wget -nc --directory-prefix={__hb_ret.path} {base_url}{srr}_1.fastq.gz
    """)

    __hb_bash(f"""
         wget -nc --directory-prefix={__hb_ret.path} {base_url}{srr}_2.fastq.gz
    """)

os.symlink(
    src=__hb_sra.sample_sheet,
    dst=f"{__hb_ret.path}/sample_sheet.csv",
)'''

[Function.load_local_rna_seq]
params.local = "LocalRnaSeq"
ret = "RnaSeqReads"
condition = [
    "ret.qc = false",
    "ret.trimmed = false",
]
info.title = "Load local data"
info.description = """# Load raw RNA-seq data already present on your computer

The raw RNA-seq files are typically in the .fastq.gz file format."""
info.hyperparameters = [
]
info.code = '''carry_over(__hb_local, __hb_ret)

os.symlink(
    src=__hb_local.sample_sheet,
    dst=f"{__hb_ret.path}/sample_sheet.csv",
)'''

[Function.fastqc]
params.reads = "RnaSeqReads"
ret = "RnaSeqReads"
condition = [
    "ret.trimmed = reads.trimmed",
    "ret.qc = true",
    "reads.qc = false",
]
info.title = "FastQC"
info.description = """# Run quality control checks on RNA-seq data with [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)

FastQC produces two HTML reports for each sample: one for the forward reads
and one for the reverse reads. These HTML reports can be individually opened
and inspected in your web browser.

The Harvard Chan Bioinformatics Core provides a
[useful tutorial](https://hbctraining.github.io/Intro-to-rnaseq-hpc-salmon/lessons/qc_fastqc_assessment.html#assessing-quality-metrics)
for assessing the outputs of FastQC."""
info.citation = "Simon Andrews. FastQC: a quality control tool for high throughput sequence data. (2010). Available online at: http://www.bioinformatics.babraham.ac.uk/projects/fastqc"
info.use = "a widely-used quality control tool for high throughput sequence data."
info.hyperparameters = [
    {name = 'FASTQC_CORES', default = '4', comment = 'The number of cores that you want FastQC to use' },
]
info.code = '''carry_over(__hb_reads, __hb_ret)

sample_sheet = pl.read_csv(f"{__hb_reads.path}/sample_sheet.csv")
fastqs = " ".join(
    (__hb_reads.path + "/" + sample_sheet["sample_name"] + "_1.fastq.gz ")
    + (__hb_reads.path + "/" + sample_sheet["sample_name"] + "_2.fastq.gz")
)

__hb_bash(f"""fastqc -t {FASTQC_CORES} -o {__hb_ret.path} {fastqs}""")'''

[Function.multiqc]
params.reads = "RnaSeqReads"
ret = "RnaSeqReads"
condition = [
    "ret.trimmed = reads.trimmed",
    "ret.qc = true",
    "reads.qc = false",
]
info.title = "MultiQC"
info.description = """# Run quality control checks on RNA-seq data with [MultiQC](https://seqera.io/multiqc/)

MultiQC aggregates the output of
[FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
quality-control checks into a single page viewable in a web browser.

The Harvard Chan Bioinformatics Core provides a
[useful tutorial](https://hbctraining.github.io/Intro-to-rnaseq-hpc-salmon/lessons/qc_fastqc_assessment.html#assessing-quality-metrics)
for assessing the outputs of FastQC that can also be used to understand
the outputs of MultiQC.

This function calls FastQC on the necessary files then aggregates them with
MultiQC."""
info.google_scholar_id = "15898044054356823756"
info.pmid = "27312411"
info.citation = "Philip Ewels, Måns Magnusson, Sverker Lundin and Max Käller. MultiQC: Summarize analysis results for multiple tools and samples in a single report. Bioinformatics (2016). doi: 10.1093/bioinformatics/btw354. PMID: 27312411"
info.additional_citations = ["Simon Andrews. FastQC: a quality control tool for high throughput sequence data. (2010). Available online at: http://www.bioinformatics.babraham.ac.uk/projects/fastqc"]
info.use = "a wrapper around FastQC that also combines all results into a single page."
info.hyperparameters = [
]
info.code = '''FASTQC_CORES = 4

carry_over(__hb_reads, __hb_ret)

sample_sheet = pl.read_csv(f"{__hb_reads.path}/sample_sheet.csv")
fastqs = " ".join(
    (__hb_reads.path + "/" + sample_sheet["sample_name"] + "_1.fastq.gz ")
    + (__hb_reads.path + "/" + sample_sheet["sample_name"] + "_2.fastq.gz")
)

__hb_bash(f"""fastqc -t {FASTQC_CORES} -o {__hb_ret.path} {fastqs}""")
__hb_bash(
    f"""uv run multiqc --filename {__hb_ret.path}/multiqc.html {__hb_ret.path}"""
)'''

[Function.cutadapt_illumina]
params.reads = "RnaSeqReads"
ret = "RnaSeqReads"
condition = [
    "reads.qc = true",
    "ret.qc = false",
    "reads.trimmed = false",
    "ret.trimmed = true",
]
info.title = "cutadapt (Illumina)"
info.description = """# Remove Illumina universal adapter for RNA-seq and poly(A) tails using [cutadapt](https://cutadapt.readthedocs.io/en/stable/).

This is typically a good step to do in an RNA-seq pre-processing pipeline,
and **typically only need to be done (at most) once**.
[Adapter trimming](https://knowledge.illumina.com/library-preparation/general/library-preparation-general-reference_material-list/000001314)
removes adapter sequences that are present due to a read length being
longer than the insert size of the sequence in a sequencer. Poly(A) tails
are the result of post-transcriptional
[polyadenylation](https://www.nature.com/articles/nsb1000_838),
and thus will not map back to a reference genome or transcriptome;
therefore, if you're not specifically looking to analyze polyadenylation,
you'll likely want to remove these tails for your analysis.

From the [cutadapt manual](https://cutadapt.readthedocs.io/en/stable/):

> Cutadapt finds and removes adapter sequences, primers, poly-A tails and
> other types of unwanted sequence from your high-throughput sequencing
> reads.

> Cleaning your data in this way is often required: Reads from small-RNA
> sequencing contain the 3’ sequencing adapter because the read is longer
> than the molecule that is sequenced. Amplicon reads start with a primer
> sequence. Poly-A tails are useful for pulling out RNA from your sample,
> but often you don’t want them to be in your reads.

> Cutadapt helps with these trimming tasks by finding the adapter or primer
> sequences in an error-tolerant way."""
info.google_scholar_id = "4180123542769751602"
info.citation = "Marcel Martin. Cutadapt removes adapter sequences from high-throughput sequencing reads. EMBnet.Journal, 17(1):10-12, May 2011. http://dx.doi.org/10.14806/ej.17.1.200"
info.hyperparameters = [
]
info.code = '''carry_over(__hb_reads, __hb_ret, file="sample_sheet.csv")

sample_sheet = pl.read_csv(f"{__hb_reads.path}/sample_sheet.csv")

for sample_name in sample_sheet["sample_name"]:
    __hb_bash(f"""uv run cutadapt \\
                --cores=0 \\
                -m 1 \\
                --poly-a \\
                -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCA \\
                -A AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT \\
                -o {__hb_ret.path}/{sample_name}_1.fastq.gz \\
                -p {__hb_ret.path}/{sample_name}_2.fastq.gz \\
                {__hb_reads.path}/{sample_name}_1.fastq.gz \\
                {__hb_reads.path}/{sample_name}_2.fastq.gz""")'''

[Type.TranscriptMatrices]
params = {}
info.title = "Transcript read counts (and TPM abundance) of RNA-seq samples"
info.description = """The goal of this step is to calculate two transcript-by-sample matrices:
- One with (estimated) read counts.
- One with TPM (transcripts-per-million) abundance.

These matrices are usually computed by using a reference transcriptome
(coding sequences) rather than a reference genome. Unless your scientific
question relates specifically to transcript information, these matrices are
often aggregated into **gene-level** read count and abundance information."""
info.code = '''@dataclass
class TranscriptMatrices:
    """Transcript read counts (and TPM abundance) of RNA-seq samples

    The goal of this step is to calculate two transcript-by-sample matrices:
    - One with (estimated) read counts.
    - One with TPM (transcripts-per-million) abundance.

    These matrices are usually computed by using a reference transcriptome
    (coding sequences) rather than a reference genome. Unless your scientific
    question relates specifically to transcript information, these matrices are
    often aggregated into **gene-level** read count and abundance information."""

    path: str'''

[Function.kallisto]
params.reads = "RnaSeqReads"
ret = "TranscriptMatrices"
condition = [
    "reads.qc = true",
]
info.title = "kallisto"
info.description = """# Quantify transcript abundances *without* alignment using [kallisto](https://pachterlab.github.io/kallisto/)

kallisto is a tool that estimates the number of times a transcript appears
using a technique called _pseudoalignment_ that is much faster than a full
alignment procedure like [STAR](https://github.com/alexdobin/STAR)'s."""
info.google_scholar_id = "15817796957364212470"
info.pmid = "27043002"
info.citation = "NL Bray, H Pimentel, P Melsted and L Pachter, Near optimal probabilistic RNA-seq quantification, Nature Biotechnology 34, p 525--527 (2016)."
info.hyperparameters = [
    {name = 'KALLISTO_INDEX', default = '"ensembl115.Homo_sapiens.GRCh38.cdna.all.kallisto.idx"', comment = 'The location of the kallisto transcriptome index on your computer' },
    {name = 'KALLISTO_CORES', default = '4', comment = 'The number of cores that you want kallisto to use' },
]
info.code = '''carry_over(__hb_reads, __hb_ret, file="sample_sheet.csv")

sample_sheet = pl.read_csv(f"{__hb_reads.path}/sample_sheet.csv")

for sample_name in sample_sheet["sample_name"]:
    __hb_bash(f"""kallisto quant \\
                -t {KALLISTO_CORES} \\
                -i {KALLISTO_INDEX} \\
                -o {__hb_ret.path}/{sample_name} \\
                {__hb_reads.path}/{sample_name}_1.fastq.gz \\
                {__hb_reads.path}/{sample_name}_2.fastq.gz""")'''

[Type.GeneMatrices]
params = {}
info.title = "Gene read counts (and TPM abundance) of RNA-seq samples"
info.description = """The goal of this step is to calculate two gene-by-sample matrices:
- One with (estimated) read counts.
- One with TPM (transcripts-per-million) abundance.

These matrices can be created using an alignment-based approach that aligns
transcripts to a reference genome in a splice-aware fashion or using
an alignment-free approach that matches transcripts against a reference
transcriptome.

If you have a reference transcriptome already available that you trust and
you are not specifically interested in scientifically studying the
alignment of your RNA-seq to the genome, then a tool that performs
quantification without alignment is generally a good choice due to their
orders-of-magnitude speedup over alignment-based procedures.

These matrices can be used for plotting, differential expression testing,
clustering, and many other downstream analyses. The following review
provides an overview of RNA-seq data analysis, including information about
read count matrices (Fig 2a and 2b are especially relevant):

> Conesa, A., Madrigal, P., Tarazona, S. et al. A survey of best practices
> for RNA-seq data analysis. Genome Biol 17, 13 (2016).
> https://doi.org/10.1186/s13059-016-0881-8"""
info.code = '''@dataclass
class GeneMatrices:
    """Gene read counts (and TPM abundance) of RNA-seq samples

    The goal of this step is to calculate two gene-by-sample matrices:
    - One with (estimated) read counts.
    - One with TPM (transcripts-per-million) abundance.

    These matrices can be created using an alignment-based approach that aligns
    transcripts to a reference genome in a splice-aware fashion or using
    an alignment-free approach that matches transcripts against a reference
    transcriptome.

    If you have a reference transcriptome already available that you trust and
    you are not specifically interested in scientifically studying the
    alignment of your RNA-seq to the genome, then a tool that performs
    quantification without alignment is generally a good choice due to their
    orders-of-magnitude speedup over alignment-based procedures.

    These matrices can be used for plotting, differential expression testing,
    clustering, and many other downstream analyses. The following review
    provides an overview of RNA-seq data analysis, including information about
    read count matrices (Fig 2a and 2b are especially relevant):

    > Conesa, A., Madrigal, P., Tarazona, S. et al. A survey of best practices
    > for RNA-seq data analysis. Genome Biol 17, 13 (2016).
    > https://doi.org/10.1186/s13059-016-0881-8"""

    path: str'''

[Function.tximport]
params.data = "TranscriptMatrices"
ret = "GeneMatrices"
condition = [
]
info.title = "tximport"
info.description = """# Aggregate transcript-level estimated counts for gene-level analysis with [tximport](https://bioconductor.org/packages/release/bioc/html/tximport.html)

Tools like [kallisto](https://pachterlab.github.io/kallisto/) and
[salmon](https://salmon.readthedocs.io/en/latest/) report transcript-level
read counts, but many analyses of interest (such as differential _gene_
expression) require gene-level data. tximport aggregates transcripts of the
same gene together for gene-level downstream analysis.

Salmon is a tool that estimates the number of times a transcript appears
using a lightweight mapping technique that is much faster than a full
alignment procedure like [STAR](https://github.com/alexdobin/STAR)'s."""
info.google_scholar_id = "5898741618830664005"
info.pmid = "26925227"
info.citation = "Soneson C, Love MI, Robinson MD (2015). Differential analyses for RNA-seq: transcript-level estimates improve gene-level inferences. F1000Research, 4. doi:10.12688/f1000research.7563.1."
info.hyperparameters = [
    {name = 'ENSEMBL_VERSION', default = '"115"', comment = 'The version of Ensembl to use for gene annotations' },
    {name = 'ENSEMBL_DATASET', default = '"hsapiens_gene_ensembl"', comment = 'The Ensembl gene annotation dataset to use' },
]
info.code = '''carry_over(__hb_data, __hb_ret, file="sample_sheet.csv")

__hb_bash(f"""
    Rscript tximport.r \\
        {ENSEMBL_VERSION} \\
        {ENSEMBL_DATASET} \\
        {__hb_data.path}/sample_sheet.csv \\
        {__hb_data.path} \\
        {__hb_ret.path}""")'''

[Type.DifferentialGeneExpression]
params.comparison_sheet = "Str"
info.title = "Differential gene expression"
info.description = """The goal of this step is to assign a score (like a _p_-value) to each gene
that ranks how differentially expressed it is between two conditions.
Among other uses, this information can be plotted in an
[MA plot](https://en.wikipedia.org/wiki/MA_plot) or a
[volcano plot](https://en.wikipedia.org/wiki/Volcano_plot_(statistics%29).

The following image shows a _typical_ RNA-seq processing workflow,
**but the details can vary a lot!**

![An overview of the RNA-seq workflow.](assets/rna-seq.png)

For example, sometimes you start with reads already quantified or trimmed,
and sometimes you need to run additional processing steps like batch
correction."""
info.param_titles.comparison_sheet = "@nosuggest:Path to CSV of comparisons to make (columns: control_condition, treatment_condition)"
info.code = '''@dataclass
class DifferentialGeneExpression:
    """Differential gene expression

    The goal of this step is to assign a score (like a _p_-value) to each gene
    that ranks how differentially expressed it is between two conditions.
    Among other uses, this information can be plotted in an
    [MA plot](https://en.wikipedia.org/wiki/MA_plot) or a
    [volcano plot](https://en.wikipedia.org/wiki/Volcano_plot_(statistics%29).

    The following image shows a _typical_ RNA-seq processing workflow,
    **but the details can vary a lot!**

    ![An overview of the RNA-seq workflow.](assets/rna-seq.png)

    For example, sometimes you start with reads already quantified or trimmed,
    and sometimes you need to run additional processing steps like batch
    correction."""

    path: str

    comparison_sheet: str
    "@nosuggest:Path to CSV of comparisons to make (columns: control_condition, treatment_condition)"'''

[Function.deseq2]
params.data = "GeneMatrices"
ret = "DifferentialGeneExpression"
condition = [
]
info.title = "DESeq2"
info.description = """# Find differentially-expressed protein-coding genes with [DESeq2](https://bioconductor.org/packages/release/bioc/html/DESeq2.html)

DESeq2 models gene expression using what is called a
<span class="more-info">
<span>
A <b>negative binomial distribution</b> is a statistical distribution
that models count data with unexplained variance, such as the
number of mRNA transcripts in a cell.  It looks like an off-center
normal distribution that is only defined for non-negative integers.
</span>
negative binomial distribution</span>,
which is much more suitable for RNA-seq data than something like a _t_-test.
DESeq2 has an
[extensive guide](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html)
about how to use DESeq2 to analyze RNA-seq data.

The above guide includes a very helpful
[list of frequently-asked questions](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#frequently-asked-questions),
including an explanation of why some adjusted _p_-values are `NA` and what
can be done to turn off that behavior."""
info.google_scholar_id = "16121678637925818947"
info.citation = "Love MI, Huber W, Anders S (2014). Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2. Genome Biology, 15, 550. doi:10.1186/s13059-014-0550-8."
info.pmid = "25516281"
info.use = "a **widely-used tool** that does **not** give you error bars."
info.hyperparameters = [
    {name = 'ENSEMBL_VERSION', default = '"115"', comment = 'The version of Ensembl to use for gene annotations' },
    {name = 'ENSEMBL_DATASET', default = '"hsapiens_gene_ensembl"', comment = 'The Ensembl gene annotation dataset to use' },
]
info.code = '''carry_over(__hb_data, __hb_ret, file="sample_sheet.csv")

__hb_bash(f"""
    Rscript deseq2.r \\
        {ENSEMBL_VERSION} \\
        {ENSEMBL_DATASET} \\
        {__hb_data.path}/sample_sheet.csv \\
        {__hb_ret.comparison_sheet} \\
        {__hb_data.path}/counts.csv \\
        {__hb_ret.path}""")'''

[Function.salmon]
params.reads = "RnaSeqReads"
ret = "TranscriptMatrices"
condition = [
    "reads.qc = true",
]
info.title = "Salmon"
info.description = """# Quantify transcript abundances *without* alignment using [Salmon](https://pachterlab.github.io/kallisto/)

Salmon is a tool that estimates the number of times a transcript appears
using a lightweight mapping technique that is much faster than a full
alignment procedure like [STAR](https://github.com/alexdobin/STAR)'s."""
info.google_scholar_id = "11462947284863466602"
info.pmid = "28263959"
info.citation = "Patro, R., Duggal, G., Love, M. I., Irizarry, R. A., & Kingsford, C. (2017). Salmon provides fast and bias-aware quantification of transcript expression. Nature Methods."
info.hyperparameters = [
    {name = 'SALMON_INDEX', default = '"put the path to the Salmon index here"', comment = 'The location of the Salmon transcriptome index on your computer' },
    {name = 'SALMON_CORES', default = '4', comment = 'The number of cores that you want Salmon to use' },
]
info.code = '''raise NotImplementedError  # Coming soon!'''

[Function.sleuth]
params.data = "TranscriptMatrices"
ret = "DifferentialGeneExpression"
condition = [
]
info.title = "sleuth"
info.description = """# Find differentially-expressed protein-coding genes with [sleuth](https://pachterlab.github.io/sleuth/)

sleuth can find differentially-expressed genes between samples and can
incorporate measurements of uncertainty using "bootstrap estimates" from
read quantifiers like [kallisto](http://pachterlab.github.io/kallisto).
sleuth also has a collection of [walkthroughs](https://pachterlab.github.io/sleuth/walkthroughs)
that demonstrate how to use it to analyze RNA-seq datasets."""
info.google_scholar_id = "1639708055766929241"
info.pmid = "28581496"
info.citation = "Harold J. Pimentel, Nicolas Bray, Suzette Puente, Páll Melsted and Lior Pachter, Differential analysis of RNA-Seq incorporating quantification uncertainty, Nature Methods (2017), advanced access http://dx.doi.org/10.1038/nmeth.4324."
info.use = "a **lesser-used (but still very common)** tool that **does** give you error bars."
info.hyperparameters = [
]
info.code = '''raise NotImplementedError  # Coming soon!'''

