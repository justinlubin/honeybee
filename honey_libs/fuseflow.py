import os
import datetime
import polars as pl
import json

from honey_lang import Helper, Input, Output, Function, __hb_bash

@Helper
class Dir:
    stage = 1

    def make(name):
        time = datetime.datetime.today().strftime("%Y-%m-%d-%H-%M-%S")
        dir = f"output-{time}/{Dir.stage * 10:03d}-{name}"
        os.makedirs(dir, exist_ok=True)
        Dir.stage += 1
        return dir


@Helper
def carry_over(src_object, dst_object, *, file=None):
    def carry_one(file):
        src = f"{src_object.path}/{file}"
        dst = f"{dst_object.path}/{file}"
        if os.path.islink(src):
            src = os.readlink(src)
        os.symlink(src=src, dst=dst)

    if file is None:
        for file in os.listdir(src_object.path):
            carry_one(file)
    else:
        carry_one(file)

@Helper
def write_schedule_json(schedule_dict, output_dir, *, filename="schedule.json"):
    os.makedirs(output_dir, exist_ok=True)
    out_path = os.path.join(output_dir, filename)
    with open(out_path, "w", encoding="utf-8") as f:
        json.dump(schedule_dict, f, indent=2, sort_keys=True)
    return out_path

@Helper
class ScheduleState:
    stream_level = None
    par_factor = None
    stream_shape = None
    block_sparse = None
    dataflow_ordering = None

    @classmethod
    def set_values(
        cls,
        *,
        stream_level=None,
        par_factor=None,
        stream_shape=None,
        block_sparse=None,
        dataflow_ordering=None,
    ):
        if stream_level is not None:
            cls.stream_level = stream_level
        if par_factor is not None:
            cls.par_factor = par_factor
        if stream_shape is not None:
            cls.stream_shape = stream_shape
        if block_sparse is not None:
            cls.block_sparse = block_sparse
        if dataflow_ordering is not None:
            cls.dataflow_ordering = dataflow_ordering

    @classmethod
    def as_dict(cls):
        return {
            "stream-parallelizer": {
                "stream-level": cls.stream_level,
                "par-factor": cls.par_factor,
            },
            "stream-vectorizer": {
                "stream-shape": cls.stream_shape,
                "enable-block-sparse": cls.block_sparse,
            },
            "dataflow-ordering": cls.dataflow_ordering,
        }

    @classmethod
    def missing_fields(cls):
        missing = []
        if cls.stream_level is None:
            missing.append("stream_level")
        if cls.par_factor is None:
            missing.append("par_factor")
        if cls.stream_shape is None:
            missing.append("stream_shape")
        if cls.block_sparse is None:
            missing.append("block_sparse")
        if cls.dataflow_ordering is None:
            missing.append("dataflow_ordering")
        return missing

################################################################################
# %% FuseFlow Schedule
@Input 
class MlirProgram: 
    """An MLIR program in your filesystem

    This is the program that we use to generate the schedule."""
    path: str 
    """Path to the MLIR program"""
    num_loops: int
    """Number of loops identified by FuseFlow compiler"""

@Input
class LoopOrderOption:
    """LoopOrderOption

    A loop ordering option generated by the FuseFlow compiler."""
    path: str
    """Path to the MLIR program this ordering applies to"""
    order: str
    """Loop order string"""

@Output 
class VectorizationPass:
    """VectorizationPass

    The goal of this step is to produce the schedule for the parallelization 
    pass in the FuseFlow compiler"""
    path: str
    mlir_path: str
    num_loops: int


@Output
class StreamShapeChoice:
    """StreamShapeChoice

    The goal of this step is to choose a stream shape for vectorization."""
    path: str

    stream_shape: int
    mlir_path: str
    num_loops: int


@Output
class BlockSparseChoice:
    """BlockSparseChoice

    The goal of this step is to choose whether block-sparse vectorization is enabled."""
    path: str

    block_sparse: bool
    mlir_path: str
    num_loops: int


@Output
class StreamLevelChoice:
    """StreamLevelChoice

    The goal of this step is to choose a stream level for parallelization."""
    path: str

    stream_level: int
    mlir_path: str


@Output
class ParallelizationPass:
    """ParallelizationPass

    The goal of this step is to produce the schedule for the parallelization 
    pass in the FuseFlow compiler"""
    path: str
    mlir_path: str


@Output
class ParFactorChoice:
    """ParFactorChoice

    The goal of this step is to choose a parallelization factor."""
    path: str

    par_factor: int
    mlir_path: str


@Output
class LoopOrderChoice:
    """LoopOrderChoice

    The goal of this step is to choose a dataflow loop ordering."""
    path: str

    order: str


@Output
class FuseFlowSchedule:
    """FuseFlowSchedule 

    The goal of this step is to produce a schedule for the FuseFlow compiler 
    that sets the parallelization and vectorization pass parameters"""
    path: str

@Function(
)
def default_schedule(__hb_ret: FuseFlowSchedule):
    """schedule 

    The function that produces a schedule."""
    ScheduleState.set_values(
        stream_level=0,
        par_factor=1,
        stream_shape=16,
        block_sparse=False,
        dataflow_ordering="",
    )
    schedule = ScheduleState.as_dict()
    write_schedule_json(schedule, __hb_ret.path)
    print(json.dumps(schedule, indent=2, sort_keys=True))


@Function(
)
def build_schedule(__hb_order: LoopOrderChoice, __hb_ret: FuseFlowSchedule):
    missing = ScheduleState.missing_fields()
    if missing:
        raise RuntimeError(
            "schedule state incomplete; missing: " + ", ".join(missing)
        )
    schedule = ScheduleState.as_dict()
    write_schedule_json(schedule, __hb_ret.path)
    print(json.dumps(schedule, indent=2, sort_keys=True))

@Function(
    "ret.stream_level = 0",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_default_stream_level(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=0)
    print("Choose default stream level (0).")

@Function(
    "ret.stream_level = 1",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_1(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=1)
    print("Choose stream level 1.")

@Function(
    "ret.stream_level = 2",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_2(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=2)
    print("Choose stream level 2.")

@Function(
    "ret.stream_level = 4",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_4(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=4)
    print("Choose stream level 4.")

@Function(
    "ret.stream_level = 8",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_8(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=8)
    print("Choose stream level 8.")

@Function(
    "ret.stream_level = 16",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_16(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=16)
    print("Choose stream level 16.")

@Function(
    "ret.stream_level = 32",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_32(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=32)
    print("Choose stream level 32.")

@Function(
    "ret.stream_level = 64",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_64(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=64)
    print("Choose stream level 64.")

@Function(
    "ret.stream_level = 128",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_128(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=128)
    print("Choose stream level 128.")

@Function(
    "ret.stream_level = 256",
    "ret.stream_level < vec.num_loops",
    "ret.mlir_path = vec.mlir_path",
)
def choose_stream_level_256(__hb_vec: VectorizationPass, __hb_ret: StreamLevelChoice):
    ScheduleState.set_values(stream_level=256)
    print("Choose stream level 256.")

@Function(
    "ret.par_factor = 1",
    "ret.mlir_path = level.mlir_path",
)
def choose_default_par_factor(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=1)
    print("Choose default par factor (1).")

@Function(
    "ret.par_factor = 2",
    "ret.mlir_path = level.mlir_path",
)
def choose_par_factor_2(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=2)
    print("Choose par factor 2.")

@Function(
    "ret.par_factor = 4",
    "ret.mlir_path = level.mlir_path",
)
def choose_par_factor_4(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=4)
    print("Choose par factor 4.")

@Function(
    "ret.par_factor = 8",
    "ret.mlir_path = level.mlir_path",
)
def choose_par_factor_8(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=8)
    print("Choose par factor 8.")

@Function(
    "ret.par_factor = 16",
    "ret.mlir_path = level.mlir_path",
)
def choose_par_factor_16(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=16)
    print("Choose par factor 16.")

@Function(
    "ret.par_factor = 32",
    "ret.mlir_path = level.mlir_path",
)
def choose_par_factor_32(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=32)
    print("Choose par factor 32.")

@Function(
    "ret.par_factor = 64",
    "ret.mlir_path = level.mlir_path",
)
def choose_par_factor_64(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=64)
    print("Choose par factor 64.")

@Function(
    "ret.par_factor = 128",
    "ret.mlir_path = level.mlir_path",
)
def choose_par_factor_128(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=128)
    print("Choose par factor 128.")

@Function(
    "ret.par_factor = 256",
    "ret.mlir_path = level.mlir_path",
)
def choose_par_factor_256(__hb_level: StreamLevelChoice, __hb_ret: ParFactorChoice):
    ScheduleState.set_values(par_factor=256)
    print("Choose par factor 256.")

@Function(
    "ret.stream_shape = 16",
    "ret.mlir_path = mlir.path",
    "ret.num_loops = mlir.num_loops",
)
def choose_default_stream_shape(__hb_mlir: MlirProgram, __hb_ret: StreamShapeChoice):
    ScheduleState.set_values(stream_shape=16)
    print("Choose default stream shape (16).")

@Function(
    "ret.stream_shape = 1",
    "ret.mlir_path = mlir.path",
    "ret.num_loops = mlir.num_loops",
)
def choose_stream_shape_1(__hb_mlir: MlirProgram, __hb_ret: StreamShapeChoice):
    ScheduleState.set_values(stream_shape=1)
    print("Choose stream shape 1.")

@Function(
    "ret.stream_shape = 2",
    "ret.mlir_path = mlir.path",
    "ret.num_loops = mlir.num_loops",
)
def choose_stream_shape_2(__hb_mlir: MlirProgram, __hb_ret: StreamShapeChoice):
    ScheduleState.set_values(stream_shape=2)
    print("Choose stream shape 2.")

@Function(
    "ret.stream_shape = 4",
    "ret.mlir_path = mlir.path",
    "ret.num_loops = mlir.num_loops",
)
def choose_stream_shape_4(__hb_mlir: MlirProgram, __hb_ret: StreamShapeChoice):
    ScheduleState.set_values(stream_shape=4)
    print("Choose stream shape 4.")

@Function(
    "ret.stream_shape = 8",
    "ret.mlir_path = mlir.path",
    "ret.num_loops = mlir.num_loops",
)
def choose_stream_shape_8(__hb_mlir: MlirProgram, __hb_ret: StreamShapeChoice):
    ScheduleState.set_values(stream_shape=8)
    print("Choose stream shape 8.")

@Function(
    "ret.stream_shape = 16",
    "ret.mlir_path = mlir.path",
    "ret.num_loops = mlir.num_loops",
)
def choose_stream_shape_16(__hb_mlir: MlirProgram, __hb_ret: StreamShapeChoice):
    ScheduleState.set_values(stream_shape=16)
    print("Choose stream shape 16.")

@Function(
    "ret.block_sparse = false",
    "ret.mlir_path = shape.mlir_path",
    "ret.num_loops = shape.num_loops",
)
def choose_default_block_sparse(__hb_shape: StreamShapeChoice, __hb_ret: BlockSparseChoice):
    ScheduleState.set_values(block_sparse=False)
    print("Choose default block sparse (false).")

@Function(
    "ret.block_sparse = true",
    "ret.mlir_path = shape.mlir_path",
    "ret.num_loops = shape.num_loops",
)
def choose_block_sparse_true(__hb_shape: StreamShapeChoice, __hb_ret: BlockSparseChoice):
    ScheduleState.set_values(block_sparse=True)
    print("Choose block sparse (true).")

@Function(
    "ret.mlir_path = block.mlir_path",
    "ret.num_loops = block.num_loops",
)
def vectorization(__hb_block: BlockSparseChoice, __hb_ret: VectorizationPass):
    print("Vectorization.")

@Function(
    "ret.mlir_path = par.mlir_path",
)
def parallelization(__hb_par: ParFactorChoice, __hb_ret: ParallelizationPass):
    print("Parallelization.")

@Function(
    "P_LoopOrderOption { path = pass.mlir_path, order = ret.order }",
)
def choose_loop_order(__hb_pass: ParallelizationPass, __hb_ret: LoopOrderChoice):
    ScheduleState.set_values(dataflow_ordering=__hb_ret.order)
    print("Choose dataflow loop order.")
