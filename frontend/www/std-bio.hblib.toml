[[Preamble]]
content = 'from dataclasses import dataclass'

[[Preamble]]
content='''def bash(command):
    import subprocess

    print(f"Running bash command:\n\n{command}\n")

    subprocess.run(
        command,
        shell=True,
        text=True,
    )'''

[[Preamble]]
content='''def capture_bash(command):
    import subprocess

    print(f"Running bash command:\n\n{command}\n")

    return subprocess.run(
        command,
        shell=True,
        capture_output=True,
        text=True,
    ).stdout.split()'''

[Type.SraRnaSeq]
params.label = "Str"
params.sample_sheet = "Str"
info.code = '''@dataclass
class SraRnaSeq:
    @dataclass
    class S:
        label: str
        sample_sheet: str

    @dataclass
    class D:
        pass'''

[Prop.P_SraRnaSeq]
params.label = "Str"
params.sample_sheet = "Str"
info.title = "RNA-seq (stored on remote Sequence Read Archive)"
info.params.label = "Label for data, like 'main' or 'JL001'"
info.params.sample_sheet = "Path to sample sheet CSV with SRA metadata (columns: srr,condition,replicate)"
info.code = '''@dataclass
class P_SraRnaSeq:
    "RNA-seq (stored on remote Sequence Read Archive)"

    label: str
    "Label for data, like 'main' or 'JL001'"

    sample_sheet: str
    "Path to sample sheet CSV with SRA metadata (columns: srr,condition,replicate)"'''

[Function.F_SraRnaSeq]
params = {}
ret = "SraRnaSeq"
condition = [
    "P_SraRnaSeq { label = ret.label, sample_sheet = ret.sample_sheet }",
]
info.code = '''def F_SraRnaSeq(ret: SraRnaSeq.S) -> SraRnaSeq.D:
    return SraRnaSeq.D()'''

[Type.LocalRnaSeq]
params.label = "Str"
params.sample_sheet = "Str"
params.path = "Str"
info.code = '''@dataclass
class LocalRnaSeq:
    @dataclass
    class S:
        label: str
        sample_sheet: str
        path: str

    @dataclass
    class D:
        pass'''

[Prop.P_LocalRnaSeq]
params.label = "Str"
params.sample_sheet = "Str"
params.path = "Str"
info.title = "RNA-seq (locally-saved)"
info.params.label = "Label for data, like 'main' or 'JPL001'"
info.params.sample_sheet = "Path to sample sheet CSV (columns: sample_name,condition,replicate)"
info.params.path = "Path to the directory containing the RNA-seq data"
info.code = '''@dataclass
class P_LocalRnaSeq:
    "RNA-seq (locally-saved)"

    label: str
    "Label for data, like 'main' or 'JPL001'"

    sample_sheet: str
    "Path to sample sheet CSV (columns: sample_name,condition,replicate)"

    path: str
    "Path to the directory containing the RNA-seq data"'''

[Function.F_LocalRnaSeq]
params = {}
ret = "LocalRnaSeq"
condition = [
    "P_LocalRnaSeq { label = ret.label, sample_sheet = ret.sample_sheet, path = ret.path }",
]
info.code = '''def F_LocalRnaSeq(ret: LocalRnaSeq.S) -> LocalRnaSeq.D:
    return LocalRnaSeq.D()'''

[Type.RnaSeq]
params.label = "Str"
params.qc = "Bool"
info.title = "RNA-seq reads"
info.description = """The goal of this step is to get RNA-seq reads.

These reads can either be raw data (that is, the direct output of a machine
like an
[Illumina sequencer](https://www.illumina.com/systems/sequencing-platforms.html), or
can be the result of pre-processing that raw data.

Many pre-processing techniques (like
[adapter trimming](https://knowledge.illumina.com/software/general/software-general-reference_material-list/000002905))
require that the RNA-seq reads undergo _quality control_ (QC) checks using
a tool like
[FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
before and after running the tool."""
info.params.label = "Label for data"
info.params.qc = "Whether or not quality checks have been run"
info.code = '''@dataclass
class RnaSeq:
    """RNA-seq reads

    The goal of this step is to get RNA-seq reads.

    These reads can either be raw data (that is, the direct output of a machine
    like an
    [Illumina sequencer](https://www.illumina.com/systems/sequencing-platforms.html), or
    can be the result of pre-processing that raw data.

    Many pre-processing techniques (like
    [adapter trimming](https://knowledge.illumina.com/software/general/software-general-reference_material-list/000002905))
    require that the RNA-seq reads undergo _quality control_ (QC) checks using
    a tool like
    [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
    before and after running the tool."""

    @dataclass
    class S:
        label: str
        "Label for data"

        qc: bool
        "Whether or not quality checks have been run"

    @dataclass
    class D:
        sample_sheet: str
        path: str'''

[Function.from_local_rna_seq]
params.local = "LocalRnaSeq"
ret = "RnaSeq"
condition = [
    "ret.label = local.label",
    "ret.qc = false",
]
info.title = "Load local data"
info.description = """This function loads raw RNA-seq data that you already have on your computer,
typically in the .fastq.gz file format."""
info.code = '''def from_local_rna_seq(local: LocalRnaSeq, ret: RnaSeq.S) -> RnaSeq.D:
    """Load local data

    This function loads raw RNA-seq data that you already have on your computer,
    typically in the .fastq.gz file format."""

    print("### Loading local RNA-seq data files... ###\n")

    return RnaSeq.D(
        sample_sheet=local.static.sample_sheet,
        path=local.static.path,
    )'''

[Function.from_sra_rna_seq]
params.sra = "SraRnaSeq"
ret = "RnaSeq"
condition = [
    "ret.label = sra.label",
    "ret.qc = false",
]
info.title = "Download from ENA"
info.description = """This function loads RNA-seq data from the
[European Nucleotide Archive](https://www.ebi.ac.uk/ena/browser/home) by
SRR accession identifiers."""
info.code = '''def from_sra_rna_seq(sra: SraRnaSeq, ret: RnaSeq.S) -> RnaSeq.D:
    """Download from ENA

    This function loads RNA-seq data from the
    [European Nucleotide Archive](https://www.ebi.ac.uk/ena/browser/home) by
    SRR accession identifiers."""

    print("### Downloading RNA-seq data files from ENA... ###\n")

    import polars as pl

    df = pl.read_csv(sra.static.sample_sheet)

    outdir = f"output/{sra.static.label}/sra/"

    for srr in df["srr"]:
        base_url = "ftp://ftp.sra.ebi.ac.uk/vol1/fastq/"
        base_url += srr[:6] + "/"
        base_url += srr[9:].zfill(3) + "/"
        base_url += srr + "/"

        # Assumes forward (_1) and reverse (_2) reads exist

        bash(f"""
             wget -nc --directory-prefix={outdir} {base_url}{srr}_1.fastq.gz
        """)

        bash(f"""
             wget -nc --directory-prefix={outdir} {base_url}{srr}_2.fastq.gz
        """)

    df.with_columns().rename({"srr": "sample_name"}).write_csv(
        outdir + "sample_sheet.csv"
    )

    return RnaSeq.D(
        sample_sheet=outdir + "sample_sheet.csv",
        path=outdir,
    )'''

[Function.fastqc]
params.data = "RnaSeq"
ret = "RnaSeq"
condition = [
    "data.qc = false",
    "ret.label = data.label",
    "ret.qc = true",
]
info.title = "FastQC"
info.description = """Run quality control checks on RNA-seq data with
[FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/).

FastQC produces two HTML reports for each sample: one for the forward reads
and one for the reverse reads. These HTML reports can be individually opened
and inspected in your web browser.

The Harvard Chan Bioinformatics Core provides a
[useful tutorial](https://hbctraining.github.io/Intro-to-rnaseq-hpc-salmon/lessons/qc_fastqc_assessment.html#assessing-quality-metrics)
for assessing the outputs of FastQC.

## Citation

If you use FastQC, please cite it as:

> Simon Andrews. FastQC: a quality control tool for high throughput
> sequence data. (2010). Available online at:
> http://www.bioinformatics.babraham.ac.uk/projects/fastqc"""
info.code = '''def fastqc(data: RnaSeq, ret: RnaSeq.S) -> RnaSeq.D:
    """FastQC

    Run quality control checks on RNA-seq data with
    [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/).

    FastQC produces two HTML reports for each sample: one for the forward reads
    and one for the reverse reads. These HTML reports can be individually opened
    and inspected in your web browser.

    The Harvard Chan Bioinformatics Core provides a
    [useful tutorial](https://hbctraining.github.io/Intro-to-rnaseq-hpc-salmon/lessons/qc_fastqc_assessment.html#assessing-quality-metrics)
    for assessing the outputs of FastQC.

    ## Citation

    If you use FastQC, please cite it as:

    > Simon Andrews. FastQC: a quality control tool for high throughput
    > sequence data. (2010). Available online at:
    > http://www.bioinformatics.babraham.ac.uk/projects/fastqc"""

    print("### Running FastQC... ###\n")

    outdir = f"output/{ret.label}/fastqc/"
    bash(f"mkdir -p {outdir}")

    import polars as pl

    df = pl.read_csv(data.dynamic.sample_sheet)
    fastqs = " ".join(
        (data.dynamic.path + df["sample_name"] + "_1.fastq.gz ")
        + (data.dynamic.path + df["sample_name"] + "_2.fastq.gz")
    )
    cores = 8

    bash(f"fastqc -t {cores} -o {outdir} {fastqs}")

    return data.dynamic'''

[Function.multiqc]
params.data = "RnaSeq"
ret = "RnaSeq"
condition = [
    "data.qc = false",
    "ret.label = data.label",
    "ret.qc = true",
]
info.title = "MultiQC"
info.description = """Run quality control checks on RNA-seq data with
[MultiQC](https://seqera.io/multiqc/).

MultiQC aggregates the output of
[FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
quality-control checks into a single page viewable in a web browser.

The Harvard Chan Bioinformatics Core provides a
[useful tutorial](https://hbctraining.github.io/Intro-to-rnaseq-hpc-salmon/lessons/qc_fastqc_assessment.html#assessing-quality-metrics)
for assessing the outputs of FastQC that can also be used to understand
the outputs of MultiQC.

## Citation

If you use MultiQC, please cite it as:

> Philip Ewels, Måns Magnusson, Sverker Lundin and Max Käller. MultiQC:
> Summarize analysis results for multiple tools and samples in a single
> report. Bioinformatics (2016). doi: 10.1093/bioinformatics/btw354.
> PMID: 27312411

This step also relies on FastQC. Please also cite it as:

> Simon Andrews. FastQC: a quality control tool for high throughput
> sequence data. (2010). Available online at:
> http://www.bioinformatics.babraham.ac.uk/projects/fastqc"""
info.code = '''def multiqc(data: RnaSeq, ret: RnaSeq.S) -> RnaSeq.D:
    """MultiQC

    Run quality control checks on RNA-seq data with
    [MultiQC](https://seqera.io/multiqc/).

    MultiQC aggregates the output of
    [FastQC](https://www.bioinformatics.babraham.ac.uk/projects/fastqc/)
    quality-control checks into a single page viewable in a web browser.

    The Harvard Chan Bioinformatics Core provides a
    [useful tutorial](https://hbctraining.github.io/Intro-to-rnaseq-hpc-salmon/lessons/qc_fastqc_assessment.html#assessing-quality-metrics)
    for assessing the outputs of FastQC that can also be used to understand
    the outputs of MultiQC.

    ## Citation

    If you use MultiQC, please cite it as:

    > Philip Ewels, Måns Magnusson, Sverker Lundin and Max Käller. MultiQC:
    > Summarize analysis results for multiple tools and samples in a single
    > report. Bioinformatics (2016). doi: 10.1093/bioinformatics/btw354.
    > PMID: 27312411

    This step also relies on FastQC. Please also cite it as:

    > Simon Andrews. FastQC: a quality control tool for high throughput
    > sequence data. (2010). Available online at:
    > http://www.bioinformatics.babraham.ac.uk/projects/fastqc"""

    print("### Running MultiQC (and pre-requisite FastQC commands)... ###")

    fastqc_outdir = f"output/{ret.label}/fastqc/"
    bash(f"mkdir -p {fastqc_outdir}")

    import polars as pl

    df = pl.read_csv(data.dynamic.sample_sheet)
    fastqs = " ".join(
        (data.dynamic.path + df["sample_name"] + "_1.fastq.gz ")
        + (data.dynamic.path + df["sample_name"] + "_2.fastq.gz")
    )
    cores = 8

    bash(f"fastqc -t {cores} -o {fastqc_outdir} {fastqs}")

    multiqc_outdir = f"output/{ret.label}/multiqc/"
    bash(f"mkdir -p {multiqc_outdir}")
    bash(f"uv run multiqc --filename {multiqc_outdir}multiqc.html {fastqc_outdir}")

    return data.dynamic'''

[Function.cutadapt_illumina]
params.data = "RnaSeq"
ret = "RnaSeq"
condition = [
    "data.qc = true",
    "ret.label = data.label",
    "ret.qc = false",
]
info.title = "cutadapt (Illumina)"
info.description = """Remove the Illumina universal adapter for RNA-seq and poly(A) tails from
an RNA-seq dataset using [cutadapt](https://cutadapt.readthedocs.io/en/stable/).

This is typically a good step to do in an RNA-seq pre-processing pipeline,
and **typically only need to be done (at most) once**.
[Adapter trimming](https://knowledge.illumina.com/library-preparation/general/library-preparation-general-reference_material-list/000001314)
removes adapter sequences that are present due to a read length being
longer than the insert size of the sequence in a sequencer. Poly(A) tails
are the result of post-transcriptional
[polyadenylation](https://www.nature.com/articles/nsb1000_838),
and thus will not map back to a reference genome or transcriptome;
therefore, if you're not specifically looking to analyze polyadenylation,
you'll likely want to remove these tails for your analysis.

From the [cutadapt manual](https://cutadapt.readthedocs.io/en/stable/):

> Cutadapt finds and removes adapter sequences, primers, poly-A tails and
> other types of unwanted sequence from your high-throughput sequencing
> reads.

> Cleaning your data in this way is often required: Reads from small-RNA
> sequencing contain the 3’ sequencing adapter because the read is longer
> than the molecule that is sequenced. Amplicon reads start with a primer
> sequence. Poly-A tails are useful for pulling out RNA from your sample,
> but often you don’t want them to be in your reads.

> Cutadapt helps with these trimming tasks by finding the adapter or primer
> sequences in an error-tolerant way. It can also modify and filter
> single-end and paired-end reads in various ways. Adapter sequences can
> contain IUPAC wildcard characters. Cutadapt can also demultiplex your
> reads.

## Citation

If you use cutadapt, please cite it as:

> Marcel Martin. Cutadapt removes adapter sequences from high-throughput
> sequencing reads. EMBnet.Journal, 17(1):10-12, May 2011.
> http://dx.doi.org/10.14806/ej.17.1.200"""
info.code = '''def cutadapt_illumina(data: RnaSeq, ret: RnaSeq.S) -> RnaSeq.D:
    """cutadapt (Illumina)

    Remove the Illumina universal adapter for RNA-seq and poly(A) tails from
    an RNA-seq dataset using [cutadapt](https://cutadapt.readthedocs.io/en/stable/).

    This is typically a good step to do in an RNA-seq pre-processing pipeline,
    and **typically only need to be done (at most) once**.
    [Adapter trimming](https://knowledge.illumina.com/library-preparation/general/library-preparation-general-reference_material-list/000001314)
    removes adapter sequences that are present due to a read length being
    longer than the insert size of the sequence in a sequencer. Poly(A) tails
    are the result of post-transcriptional
    [polyadenylation](https://www.nature.com/articles/nsb1000_838),
    and thus will not map back to a reference genome or transcriptome;
    therefore, if you're not specifically looking to analyze polyadenylation,
    you'll likely want to remove these tails for your analysis.

    From the [cutadapt manual](https://cutadapt.readthedocs.io/en/stable/):

    > Cutadapt finds and removes adapter sequences, primers, poly-A tails and
    > other types of unwanted sequence from your high-throughput sequencing
    > reads.

    > Cleaning your data in this way is often required: Reads from small-RNA
    > sequencing contain the 3’ sequencing adapter because the read is longer
    > than the molecule that is sequenced. Amplicon reads start with a primer
    > sequence. Poly-A tails are useful for pulling out RNA from your sample,
    > but often you don’t want them to be in your reads.

    > Cutadapt helps with these trimming tasks by finding the adapter or primer
    > sequences in an error-tolerant way. It can also modify and filter
    > single-end and paired-end reads in various ways. Adapter sequences can
    > contain IUPAC wildcard characters. Cutadapt can also demultiplex your
    > reads.

    ## Citation

    If you use cutadapt, please cite it as:

    > Marcel Martin. Cutadapt removes adapter sequences from high-throughput
    > sequencing reads. EMBnet.Journal, 17(1):10-12, May 2011.
    > http://dx.doi.org/10.14806/ej.17.1.200"""

    print("### Running cudapat (Illumina RNA-seq)... ###")

    outdir = f"output/{ret.label}/cutadapt_trimmed/"
    bash(f"mkdir -p {outdir}")

    import polars as pl

    df = pl.read_csv(data.dynamic.sample_sheet)

    for sample_name in df["sample_name"]:
        bash(f"""uv run cutadapt \\
                    --cores=0 \\
                    -m 1 \\
                    --poly-a \\
                    -a AGATCGGAAGAGCACACGTCTGAACTCCAGTCA \\
                    -A AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT \\
                    -o {outdir}{sample_name}_1.fastq.gz \\
                    -p {outdir}{sample_name}_2.fastq.gz \\
                    {data.dynamic.path}{sample_name}_1.fastq.gz \\
                    {data.dynamic.path}{sample_name}_2.fastq.gz""")

    return RnaSeq.D(
        sample_sheet=data.dynamic.sample_sheet,
        path=outdir,
    )'''

[Type.TranscriptMatrices]
params.label = "Str"
info.title = "Read count (and TPM abundance) matrix for RNA-seq samples"
info.description = """The goal of this step is to calculate two transcript × sample matrices:
- One with (estimated) read counts.
- One with TPM (transcripts-per-million) abundance.

These matrices can be used for plotting, differential expression testing,
clustering, and many other downstream analyses. The following review
provides an overview of RNA-seq data analysis, including information about
read count matrices:

> Conesa, A., Madrigal, P., Tarazona, S. et al. A survey of best practices
> for RNA-seq data analysis. Genome Biol 17, 13 (2016).
> https://doi.org/10.1186/s13059-016-0881-8"""
info.params.label = "Label for RNA-seq data to analyze"
info.code = '''@dataclass
class TranscriptMatrices:
    """Read count (and TPM abundance) matrix for RNA-seq samples

    The goal of this step is to calculate two transcript × sample matrices:
    - One with (estimated) read counts.
    - One with TPM (transcripts-per-million) abundance.

    These matrices can be used for plotting, differential expression testing,
    clustering, and many other downstream analyses. The following review
    provides an overview of RNA-seq data analysis, including information about
    read count matrices:

    > Conesa, A., Madrigal, P., Tarazona, S. et al. A survey of best practices
    > for RNA-seq data analysis. Genome Biol 17, 13 (2016).
    > https://doi.org/10.1186/s13059-016-0881-8"""

    @dataclass
    class S:
        label: str
        "Label for RNA-seq data to analyze"

    @dataclass
    class D:
        sample_sheet: str
        path: str'''

[Function.kallisto]
params.data = "RnaSeq"
ret = "TranscriptMatrices"
condition = [
    "data.qc = true",
    "ret.label = data.label",
]
info.title = "kallisto"
info.description = """# Quantify transcript abundances *without* alignment using kallisto

kallisto is a program for quantifying abundances of transcripts from
RNA-Seq data, or more generally of target sequences using high-throughput
sequencing reads. It is based on the novel idea of pseudoalignment for
rapidly determining the compatibility of reads with targets, without the
need for alignment. On benchmarks with standard RNA-Seq data, kallisto can
quantify 30 million human bulk RNA-seq reads in less than 3 minutes on a
Mac desktop computer using only the read sequences and a transcriptome
index that itself takes than 10 minutes to build. Pseudoalignment of reads
preserves the key information needed for quantification, and kallisto is
therefore not only fast, but also comparably accurate to other existing
quantification tools. In fact, because the pseudoalignment procedure is
robust to errors in the reads, in many benchmarks kallisto significantly
outperforms existing tools. The kallisto algorithms are described in more
detail in:

> NL Bray, H Pimentel, P Melsted and L Pachter, Near optimal probabilistic
> RNA-seq quantification, Nature Biotechnology 34, p 525--527 (2016).

*Description taken from [kallisto GitHub repository](https://github.com/pachterlab/kallisto).*"""
info.code = '''def kallisto(data: RnaSeq, ret: TranscriptMatrices.S) -> TranscriptMatrices.D:
    """kallisto

    # Quantify transcript abundances *without* alignment using kallisto

    kallisto is a program for quantifying abundances of transcripts from
    RNA-Seq data, or more generally of target sequences using high-throughput
    sequencing reads. It is based on the novel idea of pseudoalignment for
    rapidly determining the compatibility of reads with targets, without the
    need for alignment. On benchmarks with standard RNA-Seq data, kallisto can
    quantify 30 million human bulk RNA-seq reads in less than 3 minutes on a
    Mac desktop computer using only the read sequences and a transcriptome
    index that itself takes than 10 minutes to build. Pseudoalignment of reads
    preserves the key information needed for quantification, and kallisto is
    therefore not only fast, but also comparably accurate to other existing
    quantification tools. In fact, because the pseudoalignment procedure is
    robust to errors in the reads, in many benchmarks kallisto significantly
    outperforms existing tools. The kallisto algorithms are described in more
    detail in:

    > NL Bray, H Pimentel, P Melsted and L Pachter, Near optimal probabilistic
    > RNA-seq quantification, Nature Biotechnology 34, p 525--527 (2016).

    *Description taken from [kallisto GitHub repository](https://github.com/pachterlab/kallisto).*"""

    in_path = data.dynamic.path
    ret_path = f"output/{ret.label}/kallisto_quant"

    RUN(f"mkdir {ret_path}")
    for name in sample_names(data.sample_sheet):
        print(f"Running kallisto on {name}...")

        RUN(f"""kallisto quant \\
                    -t 8 \\
                    -i KALLISTO_INDEX \\
                    -o {ret_path}/{name} \\
                    {in_path}/{name}_R1.fastq.gz \\
                    {in_path}/{name}_R2.fastq.gz""")

    return TranscriptMatrices.D(
        sample_sheet=data.dynamic.sample_sheet,
        path=ret_path,
    )'''

[Function.salmon]
params.data = "RnaSeq"
ret = "TranscriptMatrices"
condition = [
    "data.qc = true",
    "ret.label = data.label",
]
info.title = "salmon"
info.description = """# Quantify transcript abundances *without* alignment using salmon

Salmon is a wicked-fast program to produce a highly-accurate,
transcript-level quantification estimates from RNA-seq data. Salmon
achieves its accuracy and speed via a number of different innovations,
including the use of selective-alignment (accurate but fast-to-compute
proxies for traditional read alignments), and massively-parallel stochastic
collapsed variational inference. The result is a versatile tool that fits
nicely into many different pipelines. For example, you can choose to make
use of our selective-alignment algorithm by providing Salmon with raw
sequencing reads, or, if it is more convenient, you can provide Salmon with
regular alignments (e.g. an unsorted BAM file with alignments to the
transcriptome produced with your favorite aligner), and it will use the
same wicked-fast, state-of-the-art inference algorithm to estimate
transcript-level abundances for your experiment.

*Description taken from [salmon GitHub repository](https://github.com/COMBINE-lab/salmon).*"""
info.code = '''def salmon(data: RnaSeq, ret: TranscriptMatrices.S) -> TranscriptMatrices.D:
    """salmon

    # Quantify transcript abundances *without* alignment using salmon

    Salmon is a wicked-fast program to produce a highly-accurate,
    transcript-level quantification estimates from RNA-seq data. Salmon
    achieves its accuracy and speed via a number of different innovations,
    including the use of selective-alignment (accurate but fast-to-compute
    proxies for traditional read alignments), and massively-parallel stochastic
    collapsed variational inference. The result is a versatile tool that fits
    nicely into many different pipelines. For example, you can choose to make
    use of our selective-alignment algorithm by providing Salmon with raw
    sequencing reads, or, if it is more convenient, you can provide Salmon with
    regular alignments (e.g. an unsorted BAM file with alignments to the
    transcriptome produced with your favorite aligner), and it will use the
    same wicked-fast, state-of-the-art inference algorithm to estimate
    transcript-level abundances for your experiment.

    *Description taken from [salmon GitHub repository](https://github.com/COMBINE-lab/salmon).*"""
    pass'''

[Function.combat_seq]
params.data = "TranscriptMatrices"
ret = "TranscriptMatrices"
condition = [
    "ret.label = data.label",
]
info.title = "ComBat-seq"
info.description = """# Correct for batch effects using ComBat-seq

ComBat-seq is a batch effect adjustment tool for bulk RNA-seq count data.
It is an improved model based on the popular
    [ComBat](https://doi.org/10.1093/biostatistics/kxj037),
to address its limitations through novel methods designed specifically for
RNA-Seq studies.  ComBat-seq takes untransformed, raw count matrix as
input. Same as ComBat, it requires a known batch variable.

We use a negative binomial regression to model batch effects, then provide
adjusted data by mapping the original data to an expected distribution if
there were no batch effects. This approach better captures the properties
of RNA-Seq count data compared to the Gaussian distribution assumed by
ComBat. ComBat-seq specifies different dispersion parameters across
batches, allowing for flexible modeling of the variance of gene expression.
In addition, ComBat-seq provides adjusted data which preserves the integer
nature of counts, so that the adjusted data are compatible with the
assumptions of state-of-the-art differential expression software (e.g.
edgeR, DESeq2, which specifically request untransformed count data).

ComBat-seq was recently published in NAR genomics and bioinformatics.
Whenever using ComBat-seq, please cite:

> Yuqing Zhang, Giovanni Parmigiani, W Evan Johnson, ComBat-seq: batch
> effect adjustment for RNA-seq count data, NAR Genomics and Bioinformatics,
> Volume 2, Issue 3, 1 September 2020, lqaa078,
> [https://doi.org/10.1093/nargab/lqaa078](https://doi.org/10.1093/nargab/lqaa078)

*Description taken from [ComBat-seq GitHub repository](https://github.com/zhangyuqing/ComBat-seq).*"""
info.code = '''def combat_seq(
    data: TranscriptMatrices, ret: TranscriptMatrices.S
) -> TranscriptMatrices.D:
    """ComBat-seq

    # Correct for batch effects using ComBat-seq

    ComBat-seq is a batch effect adjustment tool for bulk RNA-seq count data.
    It is an improved model based on the popular
        [ComBat](https://doi.org/10.1093/biostatistics/kxj037),
    to address its limitations through novel methods designed specifically for
    RNA-Seq studies.  ComBat-seq takes untransformed, raw count matrix as
    input. Same as ComBat, it requires a known batch variable.

    We use a negative binomial regression to model batch effects, then provide
    adjusted data by mapping the original data to an expected distribution if
    there were no batch effects. This approach better captures the properties
    of RNA-Seq count data compared to the Gaussian distribution assumed by
    ComBat. ComBat-seq specifies different dispersion parameters across
    batches, allowing for flexible modeling of the variance of gene expression.
    In addition, ComBat-seq provides adjusted data which preserves the integer
    nature of counts, so that the adjusted data are compatible with the
    assumptions of state-of-the-art differential expression software (e.g.
    edgeR, DESeq2, which specifically request untransformed count data).

    ComBat-seq was recently published in NAR genomics and bioinformatics.
    Whenever using ComBat-seq, please cite:

    > Yuqing Zhang, Giovanni Parmigiani, W Evan Johnson, ComBat-seq: batch
    > effect adjustment for RNA-seq count data, NAR Genomics and Bioinformatics,
    > Volume 2, Issue 3, 1 September 2020, lqaa078,
    > [https://doi.org/10.1093/nargab/lqaa078](https://doi.org/10.1093/nargab/lqaa078)

    *Description taken from [ComBat-seq GitHub repository](https://github.com/zhangyuqing/ComBat-seq).*"""
    pass'''

[Type.Alignment]
params.label = "Str"
info.title = "Alignment to a reference genome"
info.params.label = "Label for data"
info.code = '''@dataclass
class Alignment:
    "Alignment to a reference genome"

    @dataclass
    class S:
        label: str
        "Label for data"

    @dataclass
    class D:
        sample_sheet: str
        path: str'''

[Function.featureCounts]
params.data = "Alignment"
ret = "TranscriptMatrices"
condition = [
    "ret.label = data.label",
]
info.title = "featureCounts"
info.description = """# Quantify transcript abundances *after* alignment using featureCounts

featureCounts is a highly efficient general-purpose read summarization
program that counts mapped reads for genomic features such as genes, exons,
promoter, gene bodies, genomic bins and chromosomal locations. It can be
used to count both RNA-seq and genomic DNA-seq reads.

*Description taken from [featureCounts website](https://subread.sourceforge.net/featureCounts.html).*"""
info.code = '''def featureCounts(data: Alignment, ret: TranscriptMatrices.S) -> TranscriptMatrices.D:
    """featureCounts

    # Quantify transcript abundances *after* alignment using featureCounts

    featureCounts is a highly efficient general-purpose read summarization
    program that counts mapped reads for genomic features such as genes, exons,
    promoter, gene bodies, genomic bins and chromosomal locations. It can be
    used to count both RNA-seq and genomic DNA-seq reads.

    *Description taken from [featureCounts website](https://subread.sourceforge.net/featureCounts.html).*"""
    pass'''

[Function.star]
params.data = "RnaSeq"
ret = "Alignment"
condition = [
    "data.qc = true",
    "ret.label = data.label",
]
info.description = """Align spliced transcripts to a reference with STAR"""
info.code = '''def star(data: RnaSeq, ret: Alignment.S) -> Alignment.D:
    """Align spliced transcripts to a reference with STAR"""
    pass'''

[Prop.CutAndRunProp]
params.label = "Str"
params.sample_sheet = "Str"
params.raw_data = "Str"
info.title = "CUT&RUN-seq"
info.params.label = "Label for data"
info.params.sample_sheet = "Path to sample sheet CSV"
info.params.raw_data = "Path to raw FASTQ files"
info.code = '''@dataclass
class CutAndRunProp:
    "CUT&RUN-seq"

    label: str
    "Label for data"

    sample_sheet: str
    "Path to sample sheet CSV"

    raw_data: str
    "Path to raw FASTQ files"'''

[Prop.EMSeqProp]
params.label = "Str"
params.sample_sheet = "Str"
params.raw_data = "Str"
info.title = "EM-seq"
info.params.label = "Label for data"
info.params.sample_sheet = "Path to sample sheet CSV"
info.params.raw_data = "Path to raw FASTQ files"
info.code = '''@dataclass
class EMSeqProp:
    "EM-seq"

    label: str
    "Label for data"

    sample_sheet: str
    "Path to sample sheet CSV"

    raw_data: str
    "Path to raw FASTQ files"'''

[Prop.FlowProp]
params.label = "Str"
params.sample_sheet = "Str"
params.raw_data = "Str"
info.title = "Flow cytometry"
info.params.label = "Label for data"
info.params.sample_sheet = "Path to sample sheet CSV"
info.params.raw_data = "Path to raw FCS files"
info.code = '''@dataclass
class FlowProp:
    "Flow cytometry"

    label: str
    "Label for data"

    sample_sheet: str
    "Path to sample sheet CSV"

    raw_data: str
    "Path to raw FCS files"'''

[Prop.SortProp]
params.label = "Str"
info.title = "Sort cells with FACS"
info.params.label = "Label for data"
info.code = '''@dataclass
class SortProp:
    "Sort cells with FACS"

    label: str
    "Label for data"'''

[Prop.StainProp]
params.label = "Str"
info.title = "Stain cells with antibodies"
info.params.label = "Label for data"
info.code = '''@dataclass
class StainProp:
    "Stain cells with antibodies"

    label: str
    "Label for data"'''

[Prop.TransfectProp]
params.label = "Str"
params.library = "Str"
info.title = "Infect cells with CRISPR sgRNA guide library"
info.params.label = "Label for data"
info.params.library = "Path to the library file"
info.code = '''@dataclass
class TransfectProp:
    "Infect cells with CRISPR sgRNA guide library"

    label: str
    "Label for data"

    library: str
    "Path to the library file"'''

